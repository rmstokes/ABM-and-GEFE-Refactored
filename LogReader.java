import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;



/*
 * 
 * Reads in file that contains user events and extract PointAndClick (pac) objects
 * pac refers to continuous mouse movement followed by a click event.
 * Each pac event will be written into it's own separate file.
 * List of pac files is generated by what preprocessor will use to generate metrics & cdf files (one for each pac file).
 * 
 */


public class LogReader {
	
	//instance variables
	private ArrayList<String> pacFileNames; //pacFiles generated from single logFile
	private String logFile; //each logFile may contain many pac events to be extracted
	private int numSubjects;
	private int numSessionsPerUser;
	//private String directoryPath;
	private HashMap<String, Integer> sessionCount; //Key is Subject 1, Subject 2; etc.
	//private ArrayList<PointAndClick> pacList;
	
	private int regionThreshold = 150; //used to divide screen into regions.
	
	//constructor
	public LogReader(){
		sessionCount = new HashMap<String, Integer>();
		//pacList = new ArrayList<PointAndClick>();
	}
	
	public String start(String directoryPath){
		//read in directory; grab all it's subdirectories into a list
		//generateSubdirectory; generateBACFileList; generatePACFileList
		HashMap <String, ArrayList<String> > subdirectoryList = new HashMap <String, ArrayList<String> >();
		subdirectoryList = generateSubdirectoryList(directoryPath);	
		ArrayList<String> bacFileList = generateBACFileList(subdirectoryList);
		String pacFileListNames = generatePACFileList(bacFileList);
				
		return pacFileListNames;		
	}
	
	private String generatePACFileList(ArrayList<String> bacFileList) {
		//generate list of pac file names
		// add click coordinates to event stream
		// calculate and initialize click regions
		
		ArrayList <PointAndClick> pacList = addCoordToEveryClick(bacFileList);
		pacList = embedClickRegion(pacList);
		writeFilesToMemory(pacList); //possibly defer this task to another component
		String pacFileListNames = storeListNames(pacList); //store the name of the file that contains the listing of all files
				
		return pacFileListNames;
	}

	

	private String storeListNames(ArrayList<PointAndClick> pacList) {
		// TODO Auto-generated method stub
		String pacListFileNames = "pacFileListNames.txt";
		PrintWriter pw = null;
		try {
			pw = new PrintWriter(pacListFileNames);
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		for (PointAndClick pac: pacList){
			//pw = new PrintWriter(pacListFileNames);
			pw.println(pac.getTitle());
		}
		
		pw.close();
		return pacListFileNames;
	}

	private void writeFilesToMemory(ArrayList<PointAndClick> pacList) {
		//write the pacList to current directory
		System.out.println("******writing files to memory******");
		PrintWriter pw = null;
		for (PointAndClick pac: pacList){
			try {
				pw = new PrintWriter(pac.getTitle()+".txt");
				System.out.println(pac.getTitle());
				//System.out.println(pac.getTitle());
				//System.out.println();
				for (MouseMovement mm: pac.getMoves()){
					pw.print(mm.toString());
					pw.flush();
					System.out.print(mm.toString());
					//System.exit(0);
				}
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		pw.close();
	}

	private ArrayList<PointAndClick> embedClickRegion(ArrayList<PointAndClick> pacList) {
		//input: pacList with click coordinates added.
		//output: pacList with click region added to the clicks
		int groupNumber = 1;
		ArrayList<MouseClick> allClicks = new ArrayList<MouseClick>();
		for (PointAndClick pac: pacList){
			allClicks.add(pac.getClick());
		}
		for (MouseClick click: allClicks){
			if (click.isGrouped()) continue;
			ArrayList<MouseClick> group = clicksWithinDistance(allClicks, click);
			
			for (MouseClick x: group){
				if (group.size() == 1){
					x.assignToGroup(0);
					break;
				}
				x.assignToGroup(groupNumber);
			}
			groupNumber++;
		}
		
		//set the click region for the pac objects
		for (PointAndClick pac: pacList){
			pac.setClickRegion();
		}
		
		/*System.out.println(allClicks);
		System.out.println(pacList);
		System.exit(0);*/
		return pacList;
	}
	
	
	
	private ArrayList<MouseClick> clicksWithinDistance(
			ArrayList<MouseClick> clickEvents, MouseClick ungroupedClick) {
		//input: list of clicks (including coordinates), and ungrouped click
		//output: list of clicks that are within threshold of ungrouped
		
		ArrayList<MouseClick> closestToUngroupedClick = new ArrayList<MouseClick>();
		for (MouseClick click: clickEvents){
			//loop to check distance away from ungrouped for all clickEvents
			double distance = calculateDistance(click, ungroupedClick);
			if (distance <= regionThreshold) closestToUngroupedClick.add(click);
		}
		
		return closestToUngroupedClick;
	}

	private static double calculateDistance(MouseClick mc1,
			MouseClick mc2) {
		// if the clicks have the same signature then lets ignore them for now
				// so we can focus on which regions are clicked by different users in
				// diff sessions.
				if (mc1.getSignature().equals(mc2.getSignature())) {
					// System.out.println("rejecting equivalent signatures ==> "+mc1.getSignature());
					return 999;
					// System.exit(0);
				}
				double x1 = (double) mc1.getX();
				double x2 = (double) mc2.getX();

				double y1 = (double) mc1.getY();
				double y2 = (double) mc2.getY();

				double distance = Math
						.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
				return distance;
	}

	private ArrayList<PointAndClick> extractPACEvents(
			ArrayList<UserEvent> clickUpdatedEventList) {
		//input: clickUpdatedEvent; output pacList
		return null;
	}

	private ArrayList<PointAndClick> addCoordToEveryClick(
			ArrayList<String> bacFileList) {
		//input: ArrayList bacFileList; output: pacList [list of all point and click objects from all files]
		//upon return pacList will have the coordinates associated with clicks.
		System.out.println("adding coord to every click..");
		
		
		//System.exit(0);
		ArrayList<PointAndClick> clickUpdatedEventList = new ArrayList<PointAndClick>();
		ArrayList<PointAndClick> pacList = new ArrayList <PointAndClick>();
		
		for (String filename: bacFileList){
			System.out.println("top of looping through bacFileList.");
			System.out.println("filename: "+filename);
			//logic will be looped through to do the following:
			//open file; read the events portion; locate clicks that are next to mouse moves
			//set the click coordinates to the predecessor mouse move
			//repeat for all files in bacFileList
			try {
				Scanner scanner = new Scanner(new File(filename));
				System.out.println("filename: "+filename);
				int lastBackSlash = filename.lastIndexOf("\\");
				int last_I = filename.lastIndexOf("I");
				String trimmed = filename.substring(lastBackSlash, last_I);
				trimmed = trimmed.substring(9).trim();
				
				System.out.println("trimmed: "+trimmed);
				int subjectNumber = Integer.parseInt(trimmed);
				int sessionNumber = Integer.parseInt(filename.substring(filename.lastIndexOf("(")+1, filename.lastIndexOf(")")).trim());
				System.out.println("subjectNumber: "+subjectNumber+" sessionNumber: "+sessionNumber);
								
				//copy contents of file to string
				String userEventFile = scanDocument(scanner);
				userEventFile = skipMetaData(userEventFile);
				System.out.println("after skip");
				if (userEventFile == null) continue; //skip null movement streams
				
				System.out.println("userEventFile: "+userEventFile);
				
				
				//generateEventList will add coordinates to clicks and return list of user event stream
				ArrayList<PointAndClick> pacObjects = generateEventList(userEventFile, subjectNumber, sessionNumber);
				System.out.println("pacObjects size: "+pacObjects.size());
				for (PointAndClick pac: pacObjects){
					pacList.add(pac); //adds pacObject to pacList
				}
								
				
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}

		return pacList;
	}

	private ArrayList<PointAndClick> generateEventList(String events,
			int userNumber, int sessionNumber) {
		//private method called by addCoordToEveryClick
		//input is eventString; output is pacList.
		//click objects are given coordinates of previous mouse move.
		
		System.out.println("inside generateEventList");
		//System.out.println("events: "+events);
		//System.exit(0);
		//ArrayList<UserEvent> al = new ArrayList<UserEvent>();
		ArrayList <PointAndClick> pacList = new ArrayList<PointAndClick>();
		ArrayList<MouseMovement> moves = new ArrayList<MouseMovement>();
		boolean firstLoop = true;
		do {
			//events.charAt(0) should be pointing to first character of timestamp.
			if (!firstLoop){
				//advance the events string forward
				events = events.substring(events.indexOf("|")+1);
				
			}
			System.out.println("events: "+events);
			firstLoop = false;
			int timestamp = getTimeStamp(events);
			//System.out.println("timestamp: "+timestamp);
			String eventType = getEventType(events);
			switch(eventType){
			case "M":
				int x = getX(events);
				int y = getY(events);
				MouseMovement mm = new MouseMovement(x,y);
				//moves.add(mm);
				moves.add(mm); //al holds every event to be inserted into pacList
				break;
			case "C":
				// create the mouse click object
				// check if predecessor was a mouse movement and if so then
				// store coordinates in click & generate pac object
				// if predecessor was not a mouse movement then delete the
				// entire list
				MouseClick mc = new MouseClick();
				mc.addSignature(userNumber, sessionNumber);
				if (moves.isEmpty()) {
					break;
				}
				int lastIndex = moves.size() - 1;

				MouseMovement move = moves.get(lastIndex);

				mc.setX(move.getxLoc());
				mc.setY(move.getyLoc());
				PointAndClick pac = new PointAndClick(userNumber, sessionNumber);
				pac.setClick(mc);
				ArrayList<MouseMovement> mm2 = new ArrayList<MouseMovement>();
				for (MouseMovement z : moves) {
					mm2.add(z);
				}
				pac.setMoves(mm2);
				pacList.add(pac);
				// moves = new ArrayList<MouseMovement>();
				System.out.println();
				System.out.println("moves for subject# "+userNumber+" instance# "+sessionNumber+" "+moves);
				System.out.println();
				moves.clear();
				// al.add(mc);

				break;
			case "K":
				//since we have a keypress event we don't need to add anything.
				//clear any moves on the list and then advance forward in event stream.
				moves.clear();
				//moves = new ArrayList<MouseMovement>();
				//KeyPress kp = new KeyPress();
				//kp.setTimeStamp(timestamp);
				//al.add(kp);
				break;
			}
		} while (eventsRemaining(events) > 0); //returns -1 if last event
		
		
		//System.exit(0);
		return pacList;
	}

	private int getY(String events) {
		events = events.substring(events.indexOf(",")+1);
		String s = events.substring(0, events.indexOf("|"));
		return Integer.parseInt(s);
	}

	private int getX(String events) {
		System.out.println("events: "+events);
		events = events.substring(events.indexOf("M")+2);
		String s = events.substring(0, events.indexOf(","));
		
		return Integer.parseInt(s);
	}

	private String getEventType(String events) {
		//return the eventType mouseclick = C; keypress = K; mousemovement = M
		int colonLocation = events.indexOf(":");
		String eventType = ""+events.charAt(colonLocation+1);
				
		return eventType;
	}

	/*private ArrayList<UserEvent> convertStringToEventStream(String events) {
		// input: userEventFile; output: List of UserEvents with coordinates embedded to clicks
		// transform the string of events to a list of event objects
				// enqueue integers repeatedly until reach colon
				// skip colon
				// grab event type
				// dequeue integers to log timestamp into object
				// for each event log x,y coordinates (clicks/keypresses will be
				// assigned coordinates of predecessor move)
				// then advance to nearest pipe to start process over
				
				// events starts with a timestamp
				
				ArrayList<UserEvent> al = new ArrayList<UserEvent>();
				ArrayList<MouseMovement> moves = new ArrayList<MouseMovement>();
				boolean lastEvent = false;
				while (!lastEvent) {
					
					//ArrayList<MouseMovement> moves = new ArrayList<MouseMovement>();
					System.out.println("generating event list...");
					// System.exit(0);
					int start = 0; // beginning of timestamp
					System.out.println("events: " + events);
					LinkedList<Integer> queue = new LinkedList<Integer>();

					// grab the timestamp as string and then convert to integer

					while (events.charAt(start) != ':') {

						queue.add(Integer.parseInt(events.substring(start, start + 1))); // add
																							// one
																							// digit
																							// to
																							// queue

						start++;
					}
					String digits = "";
					while (!queue.isEmpty()) {
						digits += queue.pop();

					}

					// System.out.println("check");
					// System.exit(0);
					int timeStamp = Integer.parseInt(digits);
					System.out.println("timestamp: " + timeStamp);
					// System.exit(0);
					start++; // move start past colon

					// obtain event type and use it to generate UserEvent object
					String eventType = events.charAt(start) + "";
					System.out.println("eventType: " + eventType);

					switch (eventType) {
					case "M":
						// mouse movement
						System.out.println("M found");
						start += 2; // move past eventType & colon
						// System.exit(0);
						MouseMovement mm = new MouseMovement();
						mm.setTimeStamp(timeStamp);
						int commaIndex = events.indexOf(",");
						int pipeIndex = events.indexOf("|");
						String xString = events.substring(start, commaIndex);
						String yString = events.substring(commaIndex + 1, pipeIndex);
						// System.out.println("check 10");
						// System.out.println("xString: "+xString +
						// " yString: "+yString);
						int x = Integer.parseInt(xString);
						int y = Integer.parseInt(yString);
						// events = events.substring(pipeIndex+1); //trim events string
						// to start at next timestamp
						System.out.println("x: " + x + " y: " + y);
						mm.setxLoc(x);
						mm.setyLoc(y);
						al.add(mm);
						moves.add(mm); // use this to build point and click objects
						if (pipeIndex + 1 > events.length() - 1) {
							lastEvent = true;
							break;
						}

						events = events.substring(pipeIndex + 1); // trim events string
																	// to start at next
																	// timestamp
						System.out.println("events: " + events);
						// System.exit(0);
						break;
					case "C":
						// click event - assign every click event the coordinates of the
						// previous mouse movement if one exists
						System.out.println("click event");
						MouseClick mc = new MouseClick();
						mc.addSignature(userNumber, sessionNumber);
						int lastMoveIndex = al.size() - 1;
						if (lastMoveIndex < 0) {
							// no moves in the set
							System.out
									.println("Error case: no moves logged before a click");
							// create click object with (0,0) coordinates; advance past
							// click event to next timestamp
							mc.setX(0);
							mc.setY(0);
							// mc.addSignature(userNumber, sessionNumber);
							// System.out.println("signature check: "+mc.getSignature());
							// System.exit(0);
							al.add(mc);
							int nextPipe = events.indexOf("|");
							if (nextPipe + 1 > events.length() - 1) {
								lastEvent = true;
								break;
							}
							events = events.substring(nextPipe + 1);
							// System.exit(0);
							break;
							// System.exit(4);
						}
						System.out.println(al.get(lastMoveIndex).getClass().toString());
						if (al.get(lastMoveIndex).getClass().toString()
								.equals("class MouseMovement")) {
							// assign movement coordinates to new click event
							MouseMovement move = (MouseMovement) al.get(lastMoveIndex);

							mc.setX(move.getxLoc());
							mc.setY(move.getyLoc());

							System.out.println("Click coordinates set as x: "
									+ mc.getX() + " y: " + mc.getY());
							al.add(mc);
							// System.exit(0);
						} else {
							// keypress was the last event rather than a move.
							System.out
									.println("Error case: keypress was logged last so we need to search for a move.");
							System.exit(4);
						}

						// remove all the moves and keep them in order to create point
						// and click object
						System.out.println("moves.size(): " + moves.size());
						//System.exit(0);
						if (moves.size() > 0) {
							PointAndClick pac = new PointAndClick(userNumber,
									sessionNumber);
							pac.setClick(mc);
							// pac.setClickRegion();
							pac.setMoves(moves); //append moves list to pac field
							pacList.add(pac);
							//add all moves to pac moves list
							int size= moves.size();
							for (int i = 0; i < size; i++){
								
								pac.addMove(new MouseMovement(moves.get(i).getxLoc(), moves.get(i).getyLoc()));
							}
							//moves.clear();
						}

						// update the event string so that it is moved forward past the
						// click event
						int nextPipe = events.indexOf("|");
						if (nextPipe + 1 > events.length() - 1) {
							lastEvent = true;
							break;
						}
						events = events.substring(nextPipe + 1);
						// System.exit(0);
						break;
					case "K":
						// keypress event- create keypress event and trim event string
						System.out.println("keypress event");
						KeyPress kp = new KeyPress();
						kp.setTimeStamp(timeStamp);
						System.out.println("keypress timestamp: " + timeStamp);
						// trim event string to next timestamp
						nextPipe = events.indexOf("|");
						if (nextPipe + 1 > events.length() - 1) {
							lastEvent = true;
							break;
						}
						events = events.substring(nextPipe + 1);
						// System.exit(0);
						break;
					default:
						// error on event
						System.out.println("Error gathering event type");
						System.exit(4);
					}

				}// end while loop

				System.out.println("number of mouse moves: " + al.size());
				// System.exit(0);
				return al;
		
	}
*/

	
	
	private int getTimeStamp(String events) {
		//return the integer value for the timestamp
		String s = new String();
		for (int i = 0; i < events.length(); i++){
			if (events.charAt(i) == ':') break;
			s+= events.charAt(i);
		}
		
		return Integer.parseInt(s);
	}

	private int eventsRemaining(String events) {
		//if no more events in string then return -1
		//otherwise return location of 1st character in timestamp.
		
		int nextPipe = events.indexOf("|");
		if (nextPipe+1 >= events.length()-1 || events.charAt(nextPipe+1) == 'h' || 
				events.charAt(nextPipe+1) == ' ') return -1;
		return nextPipe+1;
	}

	private String skipMetaData(String userEventFile) {
		// skip past all metadata so first character is 0 to denote timestamp of first event.
		String trimmedFile = "";
		int start = 0;
		userEventFile = userEventFile.trim();
		  if (userEventFile == null || userEventFile.length() < 1) return null;
		  start = userEventFile.indexOf("X,Y");
		  
		  
		  System.out.println("x,y index: "+start);
		  System.out.println("userEventFile.length(): "+userEventFile.length());
		  if (userEventFile.length() - start <= 8) {
			  System.out.println("returning null from skip method.");
			  return null;
		  }
		  //System.out.println("userEventFile.substring(start+3): "+userEventFile.substring(start+3));
		  userEventFile = userEventFile.substring(start);
		  start = 0;
		  while (true){
			  
			  if (userEventFile.charAt(start) != '0'){
				  start++;
				  
			  } else {
				  userEventFile = userEventFile.substring(start);
				  break;
			  }
		  }
		  System.out.println("userEventFile skipped meta: "+userEventFile);
		//start+=2; //set start @ 0
		trimmedFile = userEventFile;
		return trimmedFile;
	}

	private ArrayList<String> generateBACFileList(
			HashMap<String, ArrayList<String>> subdirectoryList) {
		//input: subdirectory list; output: ArrayList of BACFileNames
		ArrayList<String> bacFileList = new ArrayList<String>();
		Iterator iterator = subdirectoryList.entrySet().iterator();
		while (iterator.hasNext()){
			Map.Entry pair = (Map.Entry)iterator.next();
			String key = (String) pair.getKey();
			bacFileList.addAll(subdirectoryList.get(key));
			System.out.println(subdirectoryList.get(key));
		}
		
		//System.out.println("check");
		
		return bacFileList;
	}

	private HashMap<String, ArrayList<String>> generateSubdirectoryList(
			String directoryPath) {
		//input is log file directoryPath; 
		//output is subdirectory dictionary <String subdirectoryName, ArrayList fileList>
		
		HashMap<String, ArrayList<String>> subdirectory = new HashMap<String, ArrayList<String>>();
			
		
		//add all the subdirectory names as keys in Hashmap
		//add empty String list as value parameter for every key
		File file = new File(directoryPath);
		String[] directories = file.list(new FilenameFilter() {
		  @Override
		  public boolean accept(File current, String name) {
		    return new File(current, name).isDirectory();
		  }
		});
		
		for (String dir: directories){
			//use dir as key value.
			subdirectory.put(dir, new ArrayList<String>());
			//System.out.println(dir);
		}
		
		////////////////////////
		
		//open up each directory and grab the files.
		
		for (String directory: directories){
			//int count = 0;
			//for each directoryName in the directory
			
			//System.out.println(directory);
			String totalPath = directoryPath+directory;
			File folder = new File(totalPath);
			File[] listOfFiles = folder.listFiles();
			ArrayList <String> fileList = new ArrayList<String>();
			int instance = 1;
			for (File file2 : listOfFiles) {
			    if (file2.isFile()) {
			    	fileList.add(totalPath+"\\"+file2.getName());
			        System.out.println(totalPath+"\\"+file2.getName());
			        
			    }
			}
			
			subdirectory.put(directory, fileList);	
			sessionCount.put(directory, fileList.size());
			//System.out.println("directory: "+directory+" fileListSize(): "+fileList.size());
		}
		//call function with numUsers & sessionNumber
		
		//System.exit(0);
		return subdirectory;
	}

	

	private ArrayList<String> scan(String logFile) throws IOException{
		this.logFile = logFile; 
		//logFile will need to be broken into pacFiles.
		//logFile is just the name of the file. we have to scan it and store it for manipulation.
		//output is list of pacFiles created from the logFile.
		
		Scanner scanner = new Scanner(logFile);
		String userEventFile = scanDocument(scanner); //userEventFile doesn't yet have userid/guid attribute
		ArrayList<String> pacFileNames = generatePacFiles(userEventFile); //generate files and return their names
		//alternative here is to create one file that has the names of all the pacFiles in it. then
		//return the file name.
		return pacFileNames;
	}
	
	private String generateFileList(){
		//return name of fileList.txt
		return null;
	}
	
	private ArrayList<String> generatePacFiles(String userEventFile) {
		//generate files and return their names
		//start by skipping metadata; then adding click coordinates to event stream
		//then calculate a region for the clicks
		//create single file for each pac event <subjectNumber, instanceNumber, clickRegion>
		//store name of each file that's created in an pacList
		//return pacList
		return null;
	}

	private static String scanDocument(Scanner scanner) {
		// store entire file as a string
		String userEventFile = "";
		while (scanner.hasNextLine()) {
			userEventFile += scanner.nextLine();
		}
		return userEventFile;
	}

}
